substitutions:
  m_name: gs-bm1-battery-monitor
  #m_prev_name: ${m_name}
  m_friendly_name: "GS BM1 Battery Monitor"
  m_api_key: "12345678"
  m_ota_password: "12345678"
  m_ap_password: "12345678"

  # https://esphome.io/components/esphome.html#esphome-creators-project
  m_project_name: GranzScientific.BM1-Battery-Monitor
  m_project_ver_num: "1.0"
  m_project_ver_let: a

esphome:
  project:
    name: ${m_project_name}
    version: ${m_project_ver_num}(${m_project_ver_let})
  name: ${m_name}
  friendly_name: ${m_friendly_name}
  on_boot:
    then:
      - script.execute: watch_for_ota_update_mode
      - script.wait: watch_for_ota_update_mode

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# https://esphome.io/components/esphome.html#adjusting-flash-writes
preferences:
  flash_write_interval: 5min

# Enable logging
logger:

# Enable Home Assistant API
api:
  id: gs_api
#  encryption:
#    key: ${m_api_key}

ota:
  - platform: esphome
    password: ${m_ota_password}

wifi:
  #networks:
    #  - ssid: !secret wifi_ssid
    #  password: !secret wifi_password
    #- ssid: !secret wifi_ssid_office
    #  password: !secret wifi_password_office
  #use_address: ${m_prev_name}.local

  # Enable fallback access point (captive portal) in case wifi connection fails
  ap:
    ssid: ${m_friendly_name}
    password: ${m_ap_password}

web_server:
  port: 80
  # embed the web server's js file to allow it work without internet access
  local: true

captive_portal:

# Sensors
sensor:
  # ESP32 internal temperature sensor
  - platform: internal_temperature
    name: "MCU Internal Temperature"
    update_interval: 5s
  # Battery voltage from voltage-divider
  - platform: adc
    name: "Battery Voltage"
    pin: GPIO0
    update_interval: 5s
    attenuation: 12dB
    samples: 10
    filters:
      - lambda: return 0.7 + (x * (9.9));
  # PCB thermistor
  - platform: ntc
    name: "Ambient Temperature"
    sensor: ntc_resistance_sensor
    calibration:
      b_constant: 3900
      reference_temperature: 25Â°C
      reference_resistance: 10kOhm
  - platform: resistance
    id: ntc_resistance_sensor
    name: "Resistance Sensor"
    sensor: ntc_source_sensor
    configuration: DOWNSTREAM
    resistor: 10.0kOhm
    internal: True # hide from home assisstant
  - platform: adc
    pin: GPIO1
    id: ntc_source_sensor
    # Never update, since we trigger it from the interval block below
    update_interval: never
    attenuation: 12dB

# Switch to power NTC
switch:
  # factory reset switch (clear wifi credentials, etc)
  - platform: factory_reset
    name: "Restart with Factory Default Settings"
  # switch to power NTC to avoid battery drain when not being read
  - platform: gpio
    pin: GPIO3
    id: ntc_pwr
    internal: True # hide from home assistant

# Interval to read NTC
interval:
  - interval: 5s
    then:
      - output.turn_on: led_out
      - switch.turn_on: ntc_pwr
      - component.update: ntc_source_sensor
      - switch.turn_off: ntc_pwr
      - output.turn_off: led_out

# Configure the PWM outputs to drive the LED and buzzer
output:
  - platform: ledc
    id: led_out
    pin: GPIO6
    channel: 4
  - platform: ledc
    id: buzzer_out
    pin: GPIO7
    channel: 0

# Buzzer tone module
rtttl:
  output: buzzer_out
  id: buzzer
  gain: 80%

# Deep sleep configuration
deep_sleep:
  id: deep_sleep_1
  run_duration: 15s
  sleep_duration: 15min

# -----------------------------------------------------------------------------
# Everything below is related to OTA update mode, which inhibits deep-sleep
# when a Home Assistant input_boolean is set 'on'.
# Normally, nothing below should need to be modified.
# -----------------------------------------------------------------------------

# This text_sensor controls re-enabling deep sleep when the HA service indicates
# there is no longer an OTA update available.
text_sensor:
  - platform: homeassistant
    name: "OTA Update Mode"
    entity_id: "input_boolean.ota_update_mode"
    id: ota_update_mode
    on_value:
      then:
        - if:
            condition:
              text_sensor.state:
                id: ota_update_mode
                state: 'on'
            then:
              - logger.log: "OTA update mode active, won't go to sleep"
              - deep_sleep.prevent: deep_sleep_1
            else:
              - logger.log: "OTA update mode inactive, will sleep between readings"
              - deep_sleep.allow: deep_sleep_1

script:
  # Script that controls the timer for how long we look for the HA connection
  - id: startup_connection_timer
    then:
      - delay: 2min
  # Script that runs on boot to watch for OTA update flag, which will prevent the device from going into deep sleep
  - id: watch_for_ota_update_mode
    then:
      # Use the onboard LED to visually check at which point of the process we are
      - output.turn_on: led_out
      # This is where the 'trick' is, workaround with the while loop until we verify that we have a connection to HA
      - script.execute: startup_connection_timer
      - while:
          condition:
            lambda: 'return (id(ota_update_mode).state == "" && id(startup_connection_timer).is_running());'
          then:
            - logger.log: "HA 'input_boolean.ota_update_mode' not found yet, retrying in 5s."
            - deep_sleep.prevent: deep_sleep_1
            - homeassistant.service:
                service: 'homeassistant.update_entity'
                data:
                  entity_id: 'input_boolean.ota_update_mode'
            # Indicate with the onboard LED
            - output.turn_off: led_out
            - delay: 50ms
            - output.turn_on: led_out
            - delay: 5s
      - homeassistant.service:
          service: 'homeassistant.update_entity'
          data:
            entity_id: 'input_boolean.ota_update_mode'
      - delay: 2s
      - if:
          condition:
            text_sensor.state:
              id: ota_update_mode
              state: 'on'
          then:
            # Flag is set 'on' - prevent the ESP32 from going to sleep
            - logger.log: "OTA update mode active, preventing deep-sleep"
            - deep_sleep.prevent: deep_sleep_1 
          else:
            - if:
                condition:
                  text_sensor.state:
                    id: ota_update_mode
                    state: 'off'
                then:
                  # Flag is set 'off' - allow the ESP32 to go into deep sleep
                  - deep_sleep.allow: deep_sleep_1
                else:
                  # No state or unexpected state (not 'on'/'off'), might be unconfigured in HA
                  - if:
                      condition:
                        wifi.connected
                      then:
                        - logger.log: "Wifi connected, but input_boolean.ota_update_mode entity missing from HA!"
                        - deep_sleep.allow: deep_sleep_1
                      else:
                        - logger.log: "Wifi not connected, will goto sleep in 5min to save battery"
                        - delay: 5min
                        - deep_sleep.enter:
                            id: deep_sleep_1
                            #sleep_duration: 30min
# -----------------------------------------------------------------------------
# Add this to your HA configuration to use the OTA Update Mode feature:
# -----------------------------------------------------------------------------
#input_boolean:
#  ota_update_mode:
#    name: "OTA Update Mode"
#    initial: off
#    icon: mdi:nature-people
